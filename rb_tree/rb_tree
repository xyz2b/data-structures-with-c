红黑树(rb_tree)

红黑树与2-3树的等价性
    2-3树
        2节点                     3节点
          a                       b c
        /   \                   /  |  \

    红黑树
          a(黑)                     c(黑)
        /   \                     /   \
                                 b(红)
                               /   \
                            定义: 所有的红色节点都是左倾斜的(对于3节点来说，将左边的元素当做右边元素的左孩子来看待，与此同时左边元素所在的节点是个红色节点，所以红色的节点一定是向左倾斜的)


    2-3树
                  42
            /           \
         17   33         50
        /   |    \      /    \
      6 12  18   37    48   66 88

    红黑树
                    42(b)
                /           \
              33(b)         50(b)
            /    \        /      \
           17(r) 37(b)   48(b)   88(b)
         /   \                  /
       12(b) 18(b)             66(r)
     /
    6(r)


初始化node默认颜色是红色
    在2-3树中添加一个节点，添加的节点永远是和一个叶子节点进行融合
    红黑树中红色的节点，其实就是代表着它和它的父亲节点，本身在2-3树中是一起的，是融合在一块的
    所以新添加的节点时候，因为新添加的节点总是要和某个节点进行融合，融合以后或者形成一个3节点，或者形成一个临时的4节点，所以红黑树中新添加节点默认设置为红色的，代表它在和红黑树等价的2-3树中对应的某个节点进行融合




红黑树定义
    1.每个节点或者是红色的，或者是黑色的

    2.根节点是黑色的
        在2-3树中，根节点是2节点或者是3节点，并且2-3树中2节点和3节点对应到红黑树中的表示如下
        如果根节点是2节点，在红黑树中相应的根节点就是黑色
        如果根节点是3节点，在红黑树中相应等价的根节点就变成了如下情况，其中b节点变成了c节点的左孩子，并且标识为了红色，在红黑树中对应的根节点是c这个节点，它的颜色是黑色
            2-3树
                2节点                     3节点
                  a                       b c
                /   \                   /  |  \

            红黑树
                  a(黑)                     c(黑)
                /   \                     /   \
                                         b(红)
                                       /   \

    3.每一个叶子节点(最后的空节点，不是左右子树都为空的节点)是黑色的
        定义NULL节点颜色是黑色的

        对于一颗空树来说，它也是一颗红黑树，对于空树来说它的根节点也是空节点，根据第2条性质根节点都是黑色，又根据第3条性质NULL节点是黑色的，它们俩相呼应

    4.如果一个节点是红色的，那么它的孩子节点都是黑色的
        在红黑树中，只有其对应的2-3树中是3节点，红黑树中才会出现红色节点
        2-3树中3节点左侧的元素所在的节点在红黑树中就是一个红色的节点，这个红色节点的孩子节点对应2-3树中是3节点的左孩子或者是中间孩子，不管它对应是左孩子还是中间孩子，在原来的2-3树中所连接的节点要么是个2节点，要么是个3节点，2节点对应到红黑树中就是黑色节点，如果它所连接的孩子节点是3节点，3节点在红黑树中的表示形式如下，要先连接上黑色的节点，再连接上左侧的对应的红色孩子，不管b所在节点所连接的两个孩子节点是2节点还是3节点，它首先连接的都是黑色节点

        2-3树
            2节点                     3节点
              a                       b c
            /   \                   /  |  \

        红黑树
              a(黑)                     c(黑)
            /   \                     /   \
                                     b(红)
                                   /   \

        推论: 黑色节点的右孩子一定是黑色的

    5.从任意一个节点到叶子节点，经过的黑色节点是一样的
        2-3树是一颗绝对平衡的树，从2-3树中的任意一个节点从发到叶子节点，所经过的节点数是一样多的
        因为2-3树是绝对平衡的，所以所有的叶子节点都在同一层，它们的深度是一致的

        在2-3树中的这个性质对应到红黑树中，就是所经过的黑色节点是一样多的，因为在2-3树中不论是2节点还是3节点转换成红黑中节点表示的时候，都会有一个黑色的节点
        所以在红黑树中，从任意节点出发，没经过一个黑色节点，就等同于在2-3树中经过了某个节点，区别就是如果在红黑树中所经过的黑色节点的左孩子是红色节点的话，就说明经过了原来2-3树中的一个3节点


红黑树是一个保持黑平衡的二叉树，是黑色的绝对平衡，严格意义上，不是平衡二叉树(左右子树高度差不能超过1)，最大的高度是2logn，查找/添加/删除元素时间复杂度O(logn)，红黑树不会像二分搜索树一样退化成链表
在红黑树上进行元素的查找相比AVL树会慢一点，但是对于红黑树来说添加/删除元素相比于AVL树要快一点，对于要经常添加/删除的数据，使用红黑树较好，但是对于存储的数据近乎不会动的话，只进行查询操作，其实AVL树性能要更好一点



红黑树添加新元素
    2-3树中添加一个新元素
        1.添加进2节点，形成一个3节点
        2.添加进3节点，暂时形成一个4节点

    永远添加红色节点


    1.在一颗空的红黑树中添加一个新节点42（保持根节点为黑色）
            37(红色)  -->  37(黑色)
        ！！！保持根节点为黑色


        不止是在根节点有用，在更一般的情况下也有用，如下

            2-3树
                   12 37         -->     12  37        -->        6  12  37         -->            12
                 /   |   \             /   |    \               /   |   |   \                  /         \
             5 6 11  18   42          6    18    42            5    11  18   42               6           37
                                    /    \                                                  /   \       /     \
                                   5      11                                               5     11    18     42
            对于2-3树添加节点的时候，比如添加一个元素5，应该添加到最左侧，形成一个临时的4节点，这个临时的4节点是5 6 11，对于这个临时的4节点，这个临时的4节点把它变成有三个2节点的子树，这个子树的根6，需要向这个临时4节点的父亲节点，也就是12 37所在的节点去融合，在融合以后就形成第3步的样子，在红黑树中，由于根节点6是向上做融合，所以在红黑树的表示中，4节点就应该是红色的
            4这个节点和父亲节点融化后，父亲节点又变成了临时的4节点，又应该转变成由3个2节点组成的子树，这个子树的根节点12继续向上融合，所以这个节点也应该是红色的
            对于临时的4节点，在2-3树中的添加过程中，每次都要向上融合一个元素，这个元素所在的节点在红黑树的表示中就应该是红色的节点，直到融合到根节点，再也不能向上走了
            所以此时12节点是红色，同时它又是整棵树的根节点，但是由于红黑树的根节点一定是黑色的，所以此时需要将12节点的红色转换成黑色

            ！！！在2-3树中所有临时的4节点需要向上融合的那个元素对应到红黑树中一定是红色的


    2.向红黑树中的"2-node"的左孩子添加元素，直接添加即可（直接添加）
        向红黑树节点的左子树插入一个新节点42

    3.向红黑树中的"2-node"的右孩子添加元素42（左旋转）
       向红黑树节点的右子树插入一个新节点42
            37(黑)
                 \
                  42(红)

        此时需要进行左旋转
            42(黑)
          /
        37(红)


        左旋转具体过程
           node.right = x.left
            x.left = node
            x.color = node.color (因为在左旋转之前的node是根节点，现在x是根节点，所以根节点的颜色应该是保持一致的，所以x的颜色和node的颜色一致)
            node.color = red    (因为新加入的节点x是和node节点形成一个新的3节点，通过左旋转之后，并没有改变这个3节点的两个元素，依然是x和node两个元素，此时根据红黑树的性质，为了表示x和node是2-3树中的3节点，现在node节点就要变成红色)

                    node(黑)
                  /     \
                 T1      x(红)
                       /   \
                      T2   T3


                     x(红)
                   /      \
                node(黑)   T3
                 /  \
                T1   T2

        左旋转只是一个子过程，可能会形成node和x都是红色的情况，但是并不影响，因为我们之后需要把左旋转形成的新的子树的根x传回去，传回去之后，还需要更多的后续处理
        在左旋转这个过程中并不维持红黑树的性质，主要做的事情是通过旋转操作，让x和node这两个元素对应到2-3树中的一个3节点

    4.向红黑树中的"3-node"的右孩子添加元素66（颜色翻转）
        红黑树中所谓红色节点的意思就是指它和它的父亲节点是融合在一起的


        红黑树
                42(黑)  -->   42(黑)        -->       42(黑)      -->      42(红)
              /             /       \              /       \            /       \
             37(红)        37(红)    66(红)       37(黑)    66(黑)      37(黑)    66(黑)

        对应到2-3树中
             3节点   融合   临时4节点      分裂     3个2节点        分裂后新树的根节点需要向上和其父亲节点进行融合
            37 42   -->   37 42 66       -->       42           ------------------------------------>
                                                 /    \         对应到红黑树中就是将新树的根节点改为红色
                                                37    66
        上述过程简称 颜色翻转(flip colors)

    5.向红黑树中的"3-node"的左孩子添加元素12（右旋转）

        红黑树                             右旋转                           改变颜色
                42(黑)  -->   42(黑)        -->       37(红)                -->      37(黑)
              /             /       \              /        \                     /           \
             37(红)        37(红)    T2           12(红)      42(黑)            12(红)       42(红)
                          /      \                          /       \                     /       \
                         12(红)   T1                       T1       T2                   T1        T2

        对应到2-3树中
             3节点   融合   临时4节点      分裂     3个2节点
            37 42   -->   12 37 42       -->       37
                                                 /    \
                                                12    42


        右旋转的具体过程
                             右旋转                                                         和上一步骤需要进行颜色翻转的树一样      之后进行颜色翻转即可
                node(黑)        -->       x(红)           -->     x(黑)                -->         x(黑)                        ---------->
              /       \               /        \              /         \                       /       \
            x(红)    T2            y(红)      node(黑)        y(红)       node(黑)               y(红)    node(红)
          /      \                          /       \
         y(红)   T1                       T1       T2


            node.left = T1
            x.right = node
            x.color = node.color
            node.color = red (经过上述处理后，y x node对应到2-3树中还是一个临时的4节点，此时还需哟让node的颜色变为红色，表示它和它的父亲节点x是融合在一起的)



    6.向红黑树中的"3-node"的中间孩子添加元素40（基于左孩子左旋转+基于本节点右旋转+颜色翻转）
         红黑树                         基于37进行左旋转，得到的树就和上一步中需要进行右旋转的树一样           基于42进行右旋转                     颜色翻转
                 42(黑)  -->   42(黑)        -->     42(黑)                                            ---------->       40(黑)             -->     40(红)
               /             /                      /                                                                 /         \                 /     \
              37(红)        37(红)               40(红)                                                              37(红)     42(红)           37(黑)   42(黑)
                                 \               /
                               40(红)          37(红)

         对应到2-3树中
              3节点   融合   临时4节点      分裂     3个2节点
             37 42   -->   37 40 42       -->       40
                                                  /    \
                                                 37    42

    总结
        向红黑树中的"3-node"中添加元素，可以使用下面一个逻辑链条串起来，区别只是在于如果按照二分搜索树的性质添加完元素的树的形状不符合对应步骤的样子话，直接跳过即可，直接跳到后面的过程中
        下述过程同样适用于向红黑树的"2-node"中添加元素，如果添加元素后，是左倾的，那下述一个步骤都不用走，如果本身是右倾的话其实就符合下面的第二种情况
        所以判断是否需要左旋转，只需要判断对于当前要处理的节点的右孩子是否是红节点即可，如果当前要处理的节点右孩子是红节点那就需要进行左旋转

              向等价于2-3树中的3节点中添加一个比3节点中小的元素要大，比大的元素要小的元素
                   |       左旋转      右旋转      颜色翻转
            黑    -->  黑   -->    黑   -->   黑    -->   红
          /          /            /         /   \      /   \
         红         红           红         红   红     黑   黑
          |           \         /               |
          |           红        红              |
          |                      |              |
          |----------------------|              |
                     |
            向等价于2-3树中的3节点中添加一个比3节点中两个元素还要小的元素
          |-------------------------------------|
                            |
          向等价于2-3树中的3节点中添加一个比3节点中两个元素都大的元素


        维护时机：和AVL树一样，添加节点回溯向上维护
        先使用二分搜索树的基本逻辑将新节点添加进红黑树中，之后再来进行红黑树性质的维护，在维护完成之后，将维护后新的根节点返回给递归调用的上一层，从上一层的角度再来看是否需要进行红黑树性质的维护，以此类推



对于完全随机的数据，普通的二分搜索树很好用
缺点: 极端情况会退化成链表(或者高度不平衡)
对于查询较多的使用情况，AVL树很好用
红黑树牺牲了平衡性(2logn的高度)
统计性能更优(综合增删改查所有的操作)




伸展树(Splay Tree)
    局部性原理: 刚被访问的内容下次高概率被再次访问
